//==================================================================
// 《剑指Offer》代码
//==================================================================

// 面试题24：反转链表
// 题目：定义一个函数，输入一个链表的头结点，反转该链表并输出反转后链表的
// 头结点。

#include <iostream>
using namespace std;

//************************************************************************************************//
//-----------------------------------------链表节点结构体-----------------------------------------//
//************************************************************************************************//
struct ListNode
{
	int value;
	ListNode* p_Next;
};

//************************************************************************************************//
//------------------------------------------创建链表节点------------------------------------------//
//************************************************************************************************//
ListNode* CreateNode(int nodeValue)
{
	ListNode* p_Node = (ListNode*)malloc(sizeof(ListNode));
	p_Node->value = nodeValue;
	p_Node->p_Next = nullptr;

	return p_Node;
}

//************************************************************************************************//
//------------------------------------------连接链表节点------------------------------------------//
//************************************************************************************************//
void ConnectNode(ListNode* p_Node1, ListNode* p_Node2)
{
	p_Node1->p_Next = p_Node2;
}

//************************************************************************************************//
//----------------------------------创建第一个测试链表（空链表）----------------------------------//
//************************************************************************************************//
ListNode* CreateList1()
{
	ListNode* p_Head = nullptr;
	return p_Head;
}
//************************************************************************************************//
//--------------------------------创建第二个测试链表（单节点链表）--------------------------------//
//************************************************************************************************//
ListNode* CreateList2()
{
	ListNode* p_Node1 = CreateNode(1);
	ListNode* p_Head = p_Node1;
	return p_Head;
}

//************************************************************************************************//
//---------------------------创建第三个测试链表（1->2->3->4->5->6->7）----------------------------//
//************************************************************************************************//
ListNode* CreateList3()
{
	ListNode* p_Node1 = CreateNode(1);
	ListNode* p_Node2 = CreateNode(2);
	ListNode* p_Node3 = CreateNode(3);
	ListNode* p_Node4 = CreateNode(4);
	ListNode* p_Node5 = CreateNode(5);
	ListNode* p_Node6 = CreateNode(6);
	ListNode* p_Node7 = CreateNode(7);

	ConnectNode(p_Node1, p_Node2);
	ConnectNode(p_Node2, p_Node3);
	ConnectNode(p_Node3, p_Node4);
	ConnectNode(p_Node4, p_Node5);
	ConnectNode(p_Node5, p_Node6);
	ConnectNode(p_Node6, p_Node7);

	ListNode* p_Head = p_Node1;
	return p_Head;
}

//************************************************************************************************//
//---------------------------------------从头至尾打印链表节点-------------------------------------//
//************************************************************************************************//
void PrintList(ListNode* p_Head)
{
	if (p_Head == nullptr)
	{
		cout << "无法打印空链表" << endl;
		return;
	}
	ListNode* p_current = p_Head;
	while (p_current->p_Next != nullptr)
	{
		cout << p_current->value << "\t";
		p_current = p_current->p_Next;
	}
	cout << p_current->value << endl;
}

//************************************************************************************************//
//-------------------------------------------反转链表函数-----------------------------------------//
//************************************************************************************************//
ListNode* ReverseList(ListNode* p_Head)
{
	if (p_Head == nullptr)
	{
		cout << "非法输入：空链表" << endl;
		return nullptr;
	}
		
	if (p_Head->p_Next == nullptr)				//单节点链表，无需反转
	{
		return p_Head;
	}
		
	ListNode* p_Pre = p_Head;					//定义3个指针，指向从头节点开始的3个相邻节点
	ListNode* p_Current = p_Pre->p_Next;
	ListNode* p_Post = p_Current->p_Next;

	p_Pre->p_Next = nullptr;					//头节点变成尾节点

	while (p_Post != nullptr)					//当p_Post到达链表尾时结束循环
	{
		p_Current->p_Next = p_Pre;				//将p_Pre与p_Current之间的指针反转
		p_Pre = p_Current;						//3个指针依次向后移动1步
		p_Current = p_Post;
		p_Post = p_Post->p_Next;
	}
	p_Current->p_Next = p_Pre;					//跳出循环时，修改最后一个指针

	return p_Current;							//返回p_Current即为头结点
}

//************************************************************************************************//
//--------------------------------------------测试函数--------------------------------------------//
//输入：ListNode* (*func)(void)（创建链表的函数指针）
//************************************************************************************************//
void Test(ListNode*(*func)())
{
	ListNode* p_Head = func();						//创建初始链表
	cout << "初始链表：" << "\t";
	PrintList(p_Head);
	ListNode* p_NewHead = ReverseList(p_Head);		//反转链表并返回新的头指针
	cout << "反转链表：" << "\t";
	PrintList(p_NewHead);
	cout << endl;
}

//************************************************************************************************//
//---------------------------------------------主函数---------------------------------------------//
//************************************************************************************************//
int main()
{
	Test(CreateList1);		//测试用例1：空链表
	Test(CreateList2);		//测试用例2：单节点链表
	Test(CreateList3);		//测试用例3：多节点链表
}