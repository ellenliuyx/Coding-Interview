//==================================================================
// 《剑指Offer》代码
//==================================================================

// 面试题25：合并两个排序的链表
// 题目：输入两个递增排序的链表，合并这两个链表并使新链表中的结点仍然是按
// 照递增排序的。例如输入图3.11中的链表1和链表2，则合并之后的升序链表如链
// 表3所示。

#include <iostream>
using namespace std;

//************************************************************************************************//
//-----------------------------------------链表节点结构体-----------------------------------------//
//************************************************************************************************//
struct ListNode
{
	int value;
	ListNode* p_Next;
};

//************************************************************************************************//
//------------------------------------------创建链表节点------------------------------------------//
//************************************************************************************************//
ListNode* CreateNode(int nodeValue)
{
	ListNode* p_Node = (ListNode*)malloc(sizeof(ListNode));
	p_Node->value = nodeValue;
	p_Node->p_Next = nullptr;

	return p_Node;
}

//************************************************************************************************//
//------------------------------------------连接链表节点------------------------------------------//
//************************************************************************************************//
void ConnectNode(ListNode* p_Node1, ListNode* p_Node2)
{
	p_Node1->p_Next = p_Node2;
}

//************************************************************************************************//
//-------------------------------------------创建空链表-------------------------------------------//
//************************************************************************************************//
ListNode* CreateList_NULL()
{
	ListNode* p_Head = nullptr;
	return p_Head;
}
//************************************************************************************************//
//-----------------------------------------创建单节点链表-----------------------------------------//
//************************************************************************************************//
ListNode* CreateList_SingleNode()
{
	ListNode* p_Node1 = CreateNode(1);
	ListNode* p_Head = p_Node1;
	return p_Head;
}

//************************************************************************************************//
//---------------------------------创建多节点链表1（1->3->5->7）----------------------------------//
//************************************************************************************************//
ListNode* CreateList1_MultiNodes()
{
	ListNode* p_Node1 = CreateNode(1);
	ListNode* p_Node2 = CreateNode(3);
	ListNode* p_Node3 = CreateNode(5);
	ListNode* p_Node4 = CreateNode(7);

	ConnectNode(p_Node1, p_Node2);
	ConnectNode(p_Node2, p_Node3);
	ConnectNode(p_Node3, p_Node4);

	ListNode* p_Head = p_Node1;
	return p_Head;
}

//************************************************************************************************//
//---------------------------------创建多节点链表2（2->4->6->8）----------------------------------//
//************************************************************************************************//
ListNode* CreateList2_MultiNodes()
{
	ListNode* p_Node1 = CreateNode(2);
	ListNode* p_Node2 = CreateNode(4);
	ListNode* p_Node3 = CreateNode(6);
	ListNode* p_Node4 = CreateNode(8);

	ConnectNode(p_Node1, p_Node2);
	ConnectNode(p_Node2, p_Node3);
	ConnectNode(p_Node3, p_Node4);

	ListNode* p_Head = p_Node1;
	return p_Head;
}

//************************************************************************************************//
//---------------------------------------从头至尾打印链表节点-------------------------------------//
//************************************************************************************************//
void PrintList(ListNode* p_Head)
{
	if (p_Head == nullptr)
	{
		cout << "空链表" << endl;
		return;
	}
	ListNode* p_current = p_Head;
	while (p_current->p_Next != nullptr)
	{
		cout << p_current->value << "\t";
		p_current = p_current->p_Next;
	}
	cout << p_current->value << endl;
}

//************************************************************************************************//
//-------------------------------------合并链表函数（递归实现）-----------------------------------//
//************************************************************************************************//
ListNode* MergeLists(ListNode* p_Head1, ListNode* p_Head2)
{
	if (p_Head1 == nullptr)				//若链表1为空，则返回链表2的头指针
		return p_Head2;
	if (p_Head2 == nullptr)				//若链表2为空，则返回链表1的头指针
		return p_Head1;

	ListNode* p_NewHead = nullptr;		//合并后的链表的头指针

	//------------取两链表较小的头结点链接到p_NewHead之后，递归调用MergeLists函数------------//
	if (p_Head1->value <= p_Head2->value)		
	{
		p_NewHead = p_Head1;
		p_NewHead->p_Next = MergeLists(p_Head1->p_Next, p_Head2);
	}
	else
	{
		p_NewHead = p_Head2;
		p_NewHead->p_Next = MergeLists(p_Head1, p_Head2->p_Next);
	}

	return p_NewHead;
}

//************************************************************************************************//
//--------------------------------------------测试函数--------------------------------------------//
//输入：ListNode* (*func)(void)（创建链表的函数指针）
//************************************************************************************************//
void Test(ListNode* (*func1)(), ListNode* (*func2)())
{
	ListNode* p_Head1 = func1();						//创建初始链表1
	ListNode* p_Head2 = func2();						//创建初始链表2
	cout << "初始链表1：" << endl;
	PrintList(p_Head1);
	cout << "初始链表2：" << endl;
	PrintList(p_Head2);

	ListNode* p_NewHead2 = MergeLists(p_Head1, p_Head2);	//递归实现合并链表并返回新的头指针
	cout << "递归实现合并链表：" << endl;
	PrintList(p_NewHead2);

	cout << endl;
}

//************************************************************************************************//
//---------------------------------------------主函数---------------------------------------------//
//************************************************************************************************//
int main()
{
	Test(CreateList_NULL, CreateList_NULL);						//测试用例1：2个空链表
	Test(CreateList_NULL, CreateList_SingleNode);				//测试用例2：1个空链表和1个单节点链表
	Test(CreateList1_MultiNodes, CreateList1_MultiNodes);		//测试用例3：2个多节点链表，无重复数值
	Test(CreateList1_MultiNodes, CreateList2_MultiNodes);		//测试用例4：2个多节点链表，有重复数值
}