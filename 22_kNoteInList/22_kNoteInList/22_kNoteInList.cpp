//==================================================================
// 《剑指Offer》代码
//==================================================================

// 面试题22：链表中倒数第k个结点
// 题目：输入一个链表，输出该链表中倒数第k个结点。为了符合大多数人的习惯，
// 本题从1开始计数，即链表的尾结点是倒数第1个结点。例如一个链表有6个结点，
// 从头结点开始它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个结点是
// 值为4的结点。

#include <iostream>
using namespace std;

//************************************************************************************************//
//-----------------------------------------链表节点结构体-----------------------------------------//
//************************************************************************************************//
struct ListNode
{
	int value;
	ListNode* p_Next;
};

//************************************************************************************************//
//------------------------------------------创建链表节点------------------------------------------//
//************************************************************************************************//
ListNode* CreateNode(int nodeValue)
{
	ListNode* p_Node = (ListNode*)malloc(sizeof(ListNode));
	p_Node->value = nodeValue;
	p_Node->p_Next = nullptr;

	return p_Node;
}

//************************************************************************************************//
//------------------------------------------连接链表节点------------------------------------------//
//************************************************************************************************//
void ConnectNode(ListNode* p_Node1, ListNode* p_Node2)
{
	p_Node1->p_Next = p_Node2;
}

//************************************************************************************************//
//-------------------------------------找到链表的倒数第k个节点------------------------------------//
//输入：ListNode* p_Head（头节点）, int k
//返回值：第k个节点
//************************************************************************************************//
ListNode* FindKthNodeToTail(ListNode* p_Head, int k)
{
	if (p_Head == nullptr)
	{
		cout << "非法输入：空链表" << endl;
		return nullptr;
	}

	if (k <= 0)
	{
		cout << "非法输入：k <= 0" << endl;
		return nullptr;
	}

	ListNode* p_Ahead = p_Head;
	ListNode* p_Behind = nullptr;

	for (int i = 0; i < k - 1; i++)			//p_Ahead走过k-1个节点
	{
		p_Ahead = p_Ahead->p_Next;
		if (p_Ahead == nullptr)				//若在k-1步内出现空指针，则链表中的节点数小于k
		{
			cout << "链表中的节点数小于 " << k << endl;
			return nullptr;
		}
	}

	p_Behind = p_Head;						//p_Ahead走过k-1个节点后，p_Behind从头节点开始

	while (p_Ahead->p_Next != nullptr)		//p_Ahead和p_Behind一起向后走，直到到达List的末尾
	{
		p_Ahead = p_Ahead->p_Next;
		p_Behind = p_Behind->p_Next;
	}

	return p_Behind;						//返回p_Behind即为倒数第k个节点
}

//************************************************************************************************//
//---------------------------------------从头至尾打印链表节点-------------------------------------//
//************************************************************************************************//
void PrintList(ListNode* p_Head)
{
	cout << "测试链表:" << "\t";
	if (p_Head == nullptr)
	{
		cout << "无法打印空链表" << endl;
		return;
	}
	ListNode* p_current = p_Head;
	while (p_current->p_Next != nullptr)
	{
		cout << p_current->value << "\t";
		p_current = p_current->p_Next;
	}
	cout << p_current->value << endl;
}

//************************************************************************************************//
//----------------------------------创建第一个测试链表（空链表）----------------------------------//
//************************************************************************************************//
ListNode* CreateList1()
{
	ListNode* p_Head = nullptr;
	PrintList(p_Head);
	return p_Head;
}

//************************************************************************************************//
//-----------------------------创建第二个测试链表（1->2->3->4->5->6）-----------------------------//
//************************************************************************************************//
ListNode* CreateList2()
{
	ListNode* p_Node1 = CreateNode(1);
	ListNode* p_Node2 = CreateNode(2);
	ListNode* p_Node3 = CreateNode(3);
	ListNode* p_Node4 = CreateNode(4);
	ListNode* p_Node5 = CreateNode(5);
	ListNode* p_Node6 = CreateNode(6);

	ConnectNode(p_Node1, p_Node2);
	ConnectNode(p_Node2, p_Node3);
	ConnectNode(p_Node3, p_Node4);
	ConnectNode(p_Node4, p_Node5);
	ConnectNode(p_Node5, p_Node6);
	
	ListNode* p_Head = p_Node1;
	PrintList(p_Head);
	return p_Head;
}

//************************************************************************************************//
//-----------------------测试函数：根据创建的链表和整数k寻找倒数第k个节点-------------------------//
//输入：ListNode* (*func)(void)（创建链表的函数指针），int k（寻找倒数第几个节点）
//************************************************************************************************//
void Test(ListNode* (*func)(void), int k)
{
	ListNode* p_KthNode = FindKthNodeToTail(func(), k);
	if (p_KthNode != nullptr)
		cout << "该链表中的倒数第 " << k << " 个节点是：" << p_KthNode->value << endl;
	else
		cout << "该链表中没有倒数第 " << k << " 个节点!" << endl;
	cout << endl;
}

//************************************************************************************************//
//---------------------------------------------主函数---------------------------------------------//
//************************************************************************************************//
int main()
{
	Test(CreateList1, 3);	//测试用例1：空链表
	Test(CreateList2, 0);	//测试用例2：k<=0
	Test(CreateList2, 3);	//测试用例3：倒数第k个节点在链表中间
	Test(CreateList2, 6);	//测试用例4：倒数第k个节点在链表头部
	Test(CreateList2, 1);	//测试用例4：倒数第k个节点在链表尾部
	Test(CreateList2, 8);	//测试用例5：k大于链表的总节点数

	return 0;
}