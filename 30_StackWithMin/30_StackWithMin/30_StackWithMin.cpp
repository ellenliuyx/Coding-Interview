//==================================================================
// 《剑指Offer》代码
//==================================================================

// 面试题30：包含min函数的栈
// 题目：定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的min
// 函数。在该栈中，调用min、push及pop的时间复杂度都是O(1)。

#include <stack>
#include <iostream>
#include <assert.h>			//防御式编程！！
using namespace std;

//********************************************************************************************//
//-----------------------------------包含min函数的栈类定义------------------------------------//
//********************************************************************************************//
template <typename T> class StackWithMin
{
public:
	StackWithMin(void);		//构造函数
	~StackWithMin(void);	//析构函数

	const T& top();			//返回栈顶元素
	void push(const T&);	//入栈函数
	void pop();				//出栈函数
	bool empty();			//判栈空函数
	int size();				//返回栈大小
	const T& min();			//返回栈最小值

private:
	stack<T> data_stack;	//数据栈
	stack<T> min_stack;		//辅助栈，存放每一步的最小值
};

//********************************************************************************************//
//------------------------------------构造函数与析构函数--------------------------------------//
//********************************************************************************************//
template <typename T> StackWithMin<T>::StackWithMin(void)	{}
template <typename T> StackWithMin<T>::~StackWithMin(void)	{}

//********************************************************************************************//
//-------------------------------------返回栈顶元素函数---------------------------------------//
//********************************************************************************************//
template <typename T> const T& StackWithMin<T>::top()
{
	assert(!data_stack.empty() && !min_stack.empty());	//防御式编程，若此句为假，则先向stderr打印一条出错信息，然后通过调用 abort 来终止程序运行。	
	
	return data_stack.top();
}

//********************************************************************************************//
//-----------------------------------------入栈函数-------------------------------------------//
//********************************************************************************************//
template <typename T> void StackWithMin<T>::push(const T& value)
{
	data_stack.push(value);

	if(min_stack.empty())			//当栈为空时，压入的第一个元素就是最小元素
		min_stack.push(value);
	else							//当栈非空时，需将min(辅助栈栈顶元素, 压入数据栈的新元素)压入辅助栈
		min_stack.push(value > min_stack.top() ? min_stack.top() : value);
}

//********************************************************************************************//
//-----------------------------------------出栈函数-------------------------------------------//
//********************************************************************************************//
template <typename T> void StackWithMin<T>::pop()
{
	assert(!data_stack.empty() && !min_stack.empty());
	
	data_stack.pop();
	min_stack.pop();
}

//********************************************************************************************//
//----------------------------------------判栈空函数------------------------------------------//
//********************************************************************************************//
template <typename T> bool StackWithMin<T>::empty()
{
	return data_stack.empty();
}

//********************************************************************************************//
//----------------------------------------栈大小函数------------------------------------------//
//********************************************************************************************//
template <typename T> int StackWithMin<T>::size()
{
	return data_stack.size();
}

//********************************************************************************************//
//---------------------------------------栈最小值函数-----------------------------------------//
//********************************************************************************************//
template <typename T> const T& StackWithMin<T>::min()
{
	assert(!data_stack.empty() && !min_stack.empty());
	
	return min_stack.top();
}

//********************************************************************************************//
//------------------------------------------主函数--------------------------------------------//
//********************************************************************************************//
int main()
{
	StackWithMin<int> myStack;		//定义一个包含min的栈对象

	myStack.push(3);											//压入3，min=3
	cout << "栈中的最小值为：" << myStack.min() << endl;
	myStack.push(4);											//压入4，min=3
	cout << "栈中的最小值为：" << myStack.min() << endl;
	myStack.push(2);											//压入2，min=2
	cout << "栈中的最小值为：" << myStack.min() << endl;
	myStack.push(1);											//压入1，min=1
	cout << "栈中的最小值为：" << myStack.min() << endl;
	myStack.pop();												//弹出，min=2
	cout << "栈中的最小值为：" << myStack.min() << endl;
	myStack.pop();												//弹出，min=3
	cout << "栈中的最小值为：" << myStack.min() << endl;
	myStack.pop();												//弹出，min=3
	cout << "栈中的最小值为：" << myStack.min() << endl;
	myStack.pop();												//弹出，此时栈空，不能返回最小值，会抛出异常
	cout << "栈中的最小值为：" << myStack.min() << endl;

	return 0;
}