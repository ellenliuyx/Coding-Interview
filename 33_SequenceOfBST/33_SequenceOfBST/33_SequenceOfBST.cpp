//==================================================================
// 《剑指Offer》代码
//==================================================================

// 面试题33：二叉搜索树的后序遍历序列
// 题目：输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。
// 如果是则返回true，否则返回false。假设输入的数组的任意两个数字都互不相同。

#include <iostream>
#include <assert.h>
using namespace std;

//************************************************************************************************//
//------------------------------判断是否为某二叉搜索树的后序遍历序列------------------------------//
//************************************************************************************************//
bool IsSequenceOfBST(int* numbers, int start, int end)
{
	assert(numbers != nullptr);		//防御式编程，非法输入

	if (start >= end)				//若头尾重合，返回true
		return true;

	int root = numbers[end];		//后序遍历序列的最后一个元素为根节点
	int index = end;				//index表示第一个比root大的元素的位置，一开始将其初始化为end，
									//如果下面的for循环没有找到比root大的元素，则说明index=end，该二叉树没有右子树
	for (int i = start; i <= end; i++)		//寻找比root大的第一个元素，下标即为index
	{
		if (numbers[i] > root)
		{
			index = i;
			break;
		}
	}
	for (int i = index; i <= end; i++)		//若index之后还有比root小的元素，则直接返回false
	{
		if (numbers[i] < root)
		{
			return false;
		}
	}

	//当左右子树均满足二叉搜索树的特征时，返回true
	return IsSequenceOfBST(numbers, start, index - 1) && IsSequenceOfBST(numbers, index, end - 1);
}

//************************************************************************************************//
//--------------------------------------------测试函数--------------------------------------------//
//************************************************************************************************//
void Test(int* numbers, int length)
{
	assert(numbers != nullptr && length != 0);

	int start = 0;
	int end = length - 1;

	for (int i = start; i <= end; i++)
	{
		cout << numbers[i] << '\t';
	}

	if (IsSequenceOfBST(numbers, start, end))
		cout << endl << "该序列 是 某二叉搜索树的后序遍历序列" << endl << endl;
	else
		cout << endl << "该序列 不是 某二叉搜索树的后序遍历序列" << endl << endl;
}

//************************************************************************************************//
//---------------------------------------------主函数---------------------------------------------//
//************************************************************************************************//
int main()
{
	//-------------------测试用例1：完全二叉搜索树的后序遍历序列------------------//
	const int length1 = 7;
	int numbers1[length1] = { 5,7,6,9,11,10,8 };
	Test(numbers1, length1);

	//-------------------测试用例2：不是二叉搜索树的后序遍历序列------------------//
	const int length2 = 4;
	int numbers2[length2] = { 7,4,6,5 };
	Test(numbers2, length2);

	//-----------测试用例3：所有结点只有右子树的二叉搜索树的后序遍历序列----------//
	const int length3 = 4;
	int numbers3[length3] = { 4,3,2,1 };
	Test(numbers3, length3);

	//------------------测试用例4：单节点二叉搜索树的后序遍历序列-----------------//
	const int length4 = 1;
	int numbers4[length4] = { 1 };
	Test(numbers4, length4);

	//--------------------测试用例5：空二叉搜索树的后序遍历序列-------------------//
	const int length5 = 0;
	int* numbers5 = nullptr;
	Test(numbers5, length5);

	return 0;
}